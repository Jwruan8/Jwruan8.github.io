<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="http://Jwruan8.github.io\img/weixin.jpg">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
      <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("your_app_id", "your_app_key");</script>

<script src="/js/Counter.js"></script>

  
<meta name="generator" content="Hexo 6.0.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://Jwruan8.github.io\img/weixin.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/"></a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主    页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Ajax/" style="font-size: 10px;">Ajax</a> <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/EL/" style="font-size: 10px;">EL</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/JDK/" style="font-size: 10px;">JDK</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/MVC/" style="font-size: 10px;">MVC</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Servlet/" style="font-size: 15px;">Servlet</a> <a href="/tags/jQuery/" style="font-size: 10px;">jQuery</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://Jwruan8.github.io\img/weixin.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主    页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Maven介绍" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/02/18/Maven%E4%BB%8B%E7%BB%8D/" class="article-date">
  	<time datetime="2022-02-18T00:43:35.000Z" itemprop="datePublished">2022-02-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/18/Maven%E4%BB%8B%E7%BB%8D/">
        Maven介绍
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第一部分："><a href="#第一部分：" class="headerlink" title="第一部分："></a>第一部分：</h1><h1 id="一、部分完成一个java项目，需要做哪些工作"><a href="#一、部分完成一个java项目，需要做哪些工作" class="headerlink" title="一、部分完成一个java项目，需要做哪些工作"></a>一、部分完成一个java项目，需要做哪些工作</h1><p>1、分析项目要做什么，知道项目有哪些组成部分。<br>2、设计项目，通过哪些步骤，使用哪些技术。需要多少人， 多长的时间。<br>3、组建团队，招人， 购置设备，服务器， 软件， 笔记本。<br>4、开发人员写代码。 开发人员需要测试自己写代码。 重复多次的工作。<br>5、测试人员，测试项目功能是否符合要求。<br>测试开发人员提交代码-如果测试有问题–需要开发人员修改–在提交代码给测试<br>测试人员在测试代码-如果还有问题-在交给开发人员-开发人员在提交-在测试<br>直到-测试代码通过。</p>
<h1 id="二、传统开发项目的问题，没有使用maven【meivn】管理的项目"><a href="#二、传统开发项目的问题，没有使用maven【meivn】管理的项目" class="headerlink" title="二、传统开发项目的问题，没有使用maven【meivn】管理的项目"></a>二、传统开发项目的问题，没有使用maven【meivn】管理的项目</h1><p>1、很多模块，模块之间有关系， 手工管理关系，比较繁琐。<br>2、需要很多第三方功能， 需要很多jar文件，需要手工从网络中获取各个jar<br>3、需要管理jar的版本， 你需要的是mysql.5.1.5.jar 拿你不能给给一个mysql.4.0.jar<br>4、管理jar文件之间的依赖， 你的项目要使用a.jar，而a.jar需要使用b.jar里面的类。<br>必须首先获取到b.jar才可以， 然后才能使用a.jar. </p>
<p>a.jar需要b.jar这个关系叫做依赖， 或者你的项目中要使用mysql的驱动，叫做项目依赖mysql驱动。<br>a.class使用b.class，a依赖b类</p>
<h1 id="三、需要改进项目的开发和管理，需要maven"><a href="#三、需要改进项目的开发和管理，需要maven" class="headerlink" title="三、需要改进项目的开发和管理，需要maven"></a>三、需要改进项目的开发和管理，需要maven</h1><p>1、maven可以管理jar文件<br>2、自动下载jar和他的文档，源代码<br>3、管理jar直接的依赖， a.jar需要b.jar ， maven会自动下载b.jar<br>4、管理你需要的jar版本<br>5、帮你编译程序，把java编译为class<br>6、帮你测试你的代码是否正确。<br>7、帮你打包文件，形成jar文件，或者war文件<br>8、帮你部署项目</p>
<h1 id="四、构建：项目的构建：-生命周期"><a href="#四、构建：项目的构建：-生命周期" class="headerlink" title="四、构建：项目的构建：(生命周期)"></a>四、构建：项目的构建：(生命周期)</h1><p>构建是面向过程的，就是一些步骤，完成项目代码的编译，测试，运行，打包，部署等等。<br>maven支持的构建包括有：<br>1、清理， 把之前项目编译的东西删除掉，为新的编译代码做准备。<br>2、编译， 把程序源代码编译为执行代码， java-class文件<br>批量的，maven可以同时把成千上百的文件编译为class。javac 不一样，javac一次编译一个文件。<br>3、测试， maven可以执行测试程序代码，验证你的功能是否正确。<br>批量的，maven同时执行多个测试代码，同时测试很多功能。<br>4、报告， 生成测试结果的文件，测试通过没有。<br>5、打包， 把你的项目中所有的class文件，配置文件等所有资源放到一个压缩文件中。<br>这个压缩文件就是项目的结果文件， 通常java程序，压缩文件是jar扩展名的。<br>对于web应用，压缩文件扩展名是.war<br>6、安装， 把5中生成的文件jar，war安装到本机仓库<br>7、部署， 把程序安装好可以执行。</p>
<h1 id="五、maven核心概念：-用好maven，了解这些概念"><a href="#五、maven核心概念：-用好maven，了解这些概念" class="headerlink" title="五、maven核心概念： 用好maven，了解这些概念"></a>五、maven核心概念： 用好maven，了解这些概念</h1><p>1、pom：一个文件，名称是pom.xml ,  pom翻译过来叫做项目对象模型。<br>maven把一个项目当做一个模型使用。控制maven构建项目的过程，管理jar依赖。<br>2、约定的目录结构 ： maven项目的目录和文件的位置都是规定的。<br>3、坐标：是一个唯一的字符串，用来表示资源的。<br>4、依赖管理：管理你的项目可以使用jar文件<br>5、仓库管理(了解)：你的资源存放的位置<br>6、生命周期(了解)：maven工具构建项目的过程，就是生命周期。<br>7、插件和目标(了解)：执行maven构建的时候用的工具是插件<br>8、继承<br>9、聚合</p>
<p>讲maven的使用，先难后易的。<br>难是说使用maven的命令，完成maven使用，在idea中直接使用maven，代替命令。</p>
<h1 id="六、maven工具的安装和配置。"><a href="#六、maven工具的安装和配置。" class="headerlink" title="六、maven工具的安装和配置。"></a>六、maven工具的安装和配置。</h1><p>1）需要从maven的官网下载maven的安装包 apache-maven-3.3.9-bin.zip，配合jdk1.8。<br>2）解压安装包，解压到一个目录，非中文目录。<br>子目录 bin：执行程序，主要是mvn.cmd<br>conf：maven工具本身的配置文件 settings.xml<br>3）配置环境变量<br>在系统的环境变量中，指定一个M2_HOME的名称， 指定它的值是maven工具安装目录，bin之前的目录<br>M2_HOME&#x3D;D:\work\maven_work\apache-maven-3.3.9<br>再把M2_HOME加入到path之中，在所有路径之前加入 %M2_HOME%\bin;</p>
<p>4）验证，新的命令行中，执行mvn -v  注意：需要配置JAVA_HOME ，指定jdk路径</p>
<p>C:\Users\Administrator&gt;mvn -v<br>出现如下内容，maven安装，配置正确。<br>Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:4<br>Maven home: D:\work\maven_work\apache-maven-3.3.9<br>Java version: 1.8.0_40, vendor: Oracle Corporation<br>Java home: C:\java\JDK8-64\jre<br>Default locale: zh_CN, platform encoding: GBK<br>OS name: “windows 7”, version: “6.1”, arch: “amd64”, family: “dos”</p>
<h1 id="第二部分："><a href="#第二部分：" class="headerlink" title="第二部分："></a>第二部分：</h1><p>Maven的核心概念：需要掌握的有四点：<br>1、Maven工程约定目录结构     2、pom文件    3、坐标     4、依赖</p>
<h1 id="一、maven约定的目录结构，-约定是大家都遵循的一个规则。"><a href="#一、maven约定的目录结构，-约定是大家都遵循的一个规则。" class="headerlink" title="一、maven约定的目录结构， 约定是大家都遵循的一个规则。"></a>一、maven约定的目录结构， 约定是大家都遵循的一个规则。</h1><p>每一个maven项目在磁盘中都是一个文件夹（项目-Hello）</p>
<table>
<thead>
<tr>
<th align="center">目录</th>
<th align="center">目录</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Hello&#x2F;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">—&#x2F;src</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">——&#x2F;main</td>
<td align="center">#放你主程序java代码和配置文件</td>
</tr>
<tr>
<td align="center">———-&#x2F;java</td>
<td align="center">#你的程序包和包中的java文件</td>
</tr>
<tr>
<td align="center">———-&#x2F;resources</td>
<td align="center">#你的java程序中要使用的配置文件</td>
</tr>
<tr>
<td align="center">——&#x2F;test</td>
<td align="center">#放测试程序代码和文件的（可以没有）</td>
</tr>
<tr>
<td align="center">———-&#x2F;java</td>
<td align="center">#测试程序包和包中的java文件</td>
</tr>
<tr>
<td align="center">———-&#x2F;resources</td>
<td align="center">#测试java程序中要使用的配置文件</td>
</tr>
<tr>
<td align="center">—&#x2F;pom.xml</td>
<td align="center">#maven的核心文件（maven项目必须有）</td>
</tr>
</tbody></table>
<h1 id="2、疑问：-mvn-compile-编译src-x2F-main目录下的所有java文件的。"><a href="#2、疑问：-mvn-compile-编译src-x2F-main目录下的所有java文件的。" class="headerlink" title="2、疑问： mvn compile 编译src&#x2F;main目录下的所有java文件的。"></a>2、疑问： mvn compile 编译src&#x2F;main目录下的所有java文件的。</h1><p>1）为什么要下载<br>maven工具执行的操作需要很多插件（java类–jar文件）完成的<br>2）下载什么东西了<br>jar文件–叫做插件–插件是完成某些功能<br>3）下载的东西存放到哪里了。<br>默认仓库（本机仓库）：<br>C:\Users\（登录操作系统的用户名）Administrator.m2\repository</p>
<p>Downloading:<br><a target="_blank" rel="noopener" href="https://repo.maven.apache.org/maven2/org">https://repo.maven.apache.org/maven2/org</a><br>&#x2F;apache&#x2F;maven&#x2F;maven-plugin-parameter-documenter-2.0.9.pom<br><a target="_blank" rel="noopener" href="https://repo.maven.apache.org/">https://repo.maven.apache.org</a> ：中央仓库的地址</p>
<p>执行mvn compile， 结果是在项目的根目录下生成target目录（结果目录），<br>maven编译的java程序，最后的class文件都放在target目录中</p>
<h2 id="设置本机存放资源的目录位置-设置本机仓库-："><a href="#设置本机存放资源的目录位置-设置本机仓库-：" class="headerlink" title="设置本机存放资源的目录位置(设置本机仓库)："></a>设置本机存放资源的目录位置(设置本机仓库)：</h2><ol>
<li><p>修改maven的配置文件， maven安装目录&#x2F;conf&#x2F;settings.xml<br>先备份 settings.xml</p>
</li>
<li><p>修改 &lt;localRepository&gt;  指定你的目录（不要使用中文目录）<br>D:\work\maven_work\maven_repository</p>
</li>
</ol>
<h1 id="三、仓库：存放maven使用的jar和我们项目使用的jar"><a href="#三、仓库：存放maven使用的jar和我们项目使用的jar" class="headerlink" title="三、仓库：存放maven使用的jar和我们项目使用的jar"></a>三、仓库：存放maven使用的jar和我们项目使用的jar</h1><p>1）仓库是什么：仓库是存放东西的， 存放maven使用的jar和我们项目使用的jar<br>maven使用的插件（各种jar）<br>我项目使用的jar(第三方的工具)<br>2）仓库的分类<br>本地仓库，就是你的个人计算机上的文件夹，存放各种jar<br>远程仓库，在互联网上的，使用网络才能使用的仓库<br>①：中央仓库，最权威的， 所有的开发人员都共享使用的一个集中的仓库，<br><a target="_blank" rel="noopener" href="https://repo.maven.apache.org/">https://repo.maven.apache.org</a> ：中央仓库的地址<br>②：中央仓库的镜像：就是中央仓库的备份， 在各大洲，重要的城市都是镜像。<br>③：私服，在公司内部，在局域网中使用的， 不是对外使用的。<br>3）仓库的使用，maven仓库的使用不需要人为参与。<br>开发人员需要使用mysql驱动—&gt;<br>maven首查本地仓库—&gt;再查私服—&gt;镜像—&gt;中央仓库（顺序，一层一层）</p>
<h1 id="四、pom：项目对象模型，是一个pom-xml文件，是maven的灵魂！有五个属性"><a href="#四、pom：项目对象模型，是一个pom-xml文件，是maven的灵魂！有五个属性" class="headerlink" title="四、pom：项目对象模型，是一个pom.xml文件，是maven的灵魂！有五个属性"></a>四、pom：项目对象模型，是一个pom.xml文件，是maven的灵魂！有五个属性</h1><h2 id="1、坐标：唯一值，-在互联网中唯一标识一个项目的"><a href="#1、坐标：唯一值，-在互联网中唯一标识一个项目的" class="headerlink" title="1、坐标：唯一值， 在互联网中唯一标识一个项目的"></a>1、坐标：唯一值， 在互联网中唯一标识一个项目的</h2><p>&lt;groupId&gt;公司域名的倒写&lt;&#x2F;groupId&gt;<br>&lt;artifactId&gt;自定义项目名称&lt;&#x2F;artifactId&gt;<br>&lt;version&gt;自定版本号&lt;&#x2F;version&gt;<br><a target="_blank" rel="noopener" href="https://mvnrepository.com/">https://mvnrepository.com/</a> 搜索使用的中央仓库， 使用groupId 或者 artifactId作为搜索条件</p>
<h2 id="2、packaging：-打包后压缩文件的扩展名，默认是jar-，web应用是war"><a href="#2、packaging：-打包后压缩文件的扩展名，默认是jar-，web应用是war" class="headerlink" title="2、packaging： 打包后压缩文件的扩展名，默认是jar ，web应用是war"></a>2、packaging： 打包后压缩文件的扩展名，默认是jar ，web应用是war</h2><p>packaging 可以不写， 默认是jar</p>
<h2 id="3、依赖：dependencies-和dependency-，相当于是-java代码中import"><a href="#3、依赖：dependencies-和dependency-，相当于是-java代码中import" class="headerlink" title="3、依赖：dependencies 和dependency ，相当于是 java代码中import"></a>3、依赖：dependencies 和dependency ，相当于是 java代码中import</h2><p>你的项目中要使用的各种资源说明， 比如我的项目要使用mysql驱动<br>&lt;dependencies&gt;<br>&lt;!–依赖  java代码中 import –&gt;<br>&lt;dependency&gt;<br>&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;<br>&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;<br>&lt;version&gt;5.1.9&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;&#x2F;dependencies&gt;</p>
<h2 id="4、properties：设置属性，"><a href="#4、properties：设置属性，" class="headerlink" title="4、properties：设置属性，"></a>4、properties：设置属性，</h2><p>如上面的版本号，名字等</p>
<h2 id="5、build：maven在进行项目的构建时，配置信息，"><a href="#5、build：maven在进行项目的构建时，配置信息，" class="headerlink" title="5、build：maven在进行项目的构建时，配置信息，"></a>5、build：maven在进行项目的构建时，配置信息，</h2><p>例如指定编译java代码使用的jdk的版本等</p>
<h1 id="五、maven生命周期，-maven的命令，maven的插件"><a href="#五、maven生命周期，-maven的命令，maven的插件" class="headerlink" title="五、maven生命周期， maven的命令，maven的插件"></a>五、maven生命周期， maven的命令，maven的插件</h1><p>maven的生命周期：就是maven构建项目的过程，清理，编译，测试，报告，打包，安装，部署（七）<br>maven的命令：maven独立使用，通过命令，完成maven的生命周期的执行。<br>maven可以使用命令，完成项目的清理，编译，测试等等</p>
<p>maven的插件：maven命令执行时，真正完成功能的是插件，插件就是一些jar文件， 一些类。</p>
<h2 id="1、单元测试（测试方法）：用的是junit，-junit是一个专门测试的框架（工具）。"><a href="#1、单元测试（测试方法）：用的是junit，-junit是一个专门测试的框架（工具）。" class="headerlink" title="1、单元测试（测试方法）：用的是junit， junit是一个专门测试的框架（工具）。"></a>1、单元测试（测试方法）：用的是junit， junit是一个专门测试的框架（工具）。</h2><p>junit测试的内容： 测试的是类中的方法， 每一个方法都是独立测试的。<br>方法是测试的基本单位（单元），判断你类是否正确，可以测试你的每一个方法是否达到了预期功能。</p>
<p>maven借助单元测试，批量的测试你类中的大量方法是否符合预期的。</p>
<h2 id="2、使用步骤"><a href="#2、使用步骤" class="headerlink" title="2、使用步骤"></a>2、使用步骤</h2><p>1）加入依赖，在pom.xml加入单元测试依赖<br>&lt;!– 单元测试 –&gt;<br>&lt;dependency&gt;<br>&lt;groupId&gt;junit&lt;&#x2F;groupId&gt;<br>&lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;<br>&lt;version&gt;4.11&lt;&#x2F;version&gt;<br>&lt;scope&gt;test&lt;&#x2F;scope&gt;<br>&lt;&#x2F;dependency&gt;</p>
<p>2）在maven项目中的src&#x2F;test&#x2F;java目录下，创建测试程序。<br>推荐的创建类和方法的提示：<br>1）测试类的名称 是Test + 你要测试的类名<br>2）测试的方法名称 是：Test + 方法名称</p>
<p>例如你要测试HelloMaven ,<br>创建测试类 TestHelloMaven<br>@Test<br>public void testAdd(){<br>测试HelloMaven的add方法是否正确<br>}</p>
<p>其中testAdd叫做测试方法，它的定义规则</p>
<ol>
<li>方法是public的，必须的</li>
<li>方法没有返回值， 必须的</li>
<li>方法名称是自定义的，推荐是Test + 方法名称</li>
<li>在方法的上面加入 @Test</li>
</ol>
<p>3）mvn compile<br>编译main&#x2F;java&#x2F;目录下的java为class文件， 同时把class拷贝到 target&#x2F;classes目录下面<br>把main&#x2F;resources目录下的所有文件都拷贝到target&#x2F;classes目录下</p>
<h2 id="3、插件"><a href="#3、插件" class="headerlink" title="3、插件"></a>3、插件</h2><p>插件可以在自己的项目中设置，最常使用的是maven编译插件。<br>设置项目使用的 jdk 版本时通过编译插件指定。pom.xml 文件&lt;build&gt;中设置。<br>&lt;build&gt;<br>&lt;!– 配置插件 –&gt;<br>&lt;plugins&gt;<br>&lt;!– 配置具体的插件 –&gt;<br>&lt;plugin&gt;<br>&lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;<br>&lt;!– 插件的名称 –&gt;<br>&lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;<br>&lt;!– 插件的版本 –&gt;<br>&lt;version&gt;3.8.1&lt;&#x2F;version&gt;<br>&lt;!– 配置插件的信息 –&gt;<br>&lt;configuration&gt;<br>&lt;!– 告诉maven 我们写的代码实在jdk1.8上面编译的 –&gt;<br>&lt;source&gt;1.8&lt;&#x2F;source&gt;<br>&lt;!– 我们的程序应该运行在1.8的jdk上 –&gt;<br>&lt;target&gt;1.8&lt;&#x2F;target&gt;<br>&lt;&#x2F;configuration&gt;<br>&lt;&#x2F;plugin&gt;<br>&lt;&#x2F;plugins&gt;<br>&lt;&#x2F;build&gt;</p>
<h1 id="第三部分："><a href="#第三部分：" class="headerlink" title="第三部分："></a>第三部分：</h1><h1 id="一、在idea中设置maven-，让idea和maven结合使用。"><a href="#一、在idea中设置maven-，让idea和maven结合使用。" class="headerlink" title="一、在idea中设置maven ，让idea和maven结合使用。"></a>一、在idea中设置maven ，让idea和maven结合使用。</h1><p>idea中内置了maven ，一般不使用内置的， 因为用内置修改maven的设置不方便。<br>使用自己安装的maven， 需要覆盖idea中的默认的设置。让idea指定maven安装位置等信息</p>
<p>配置的入口<br>①：配置当前工程的设置， file–settings —Build, Excution,Deployment–Build Tools<br>–Maven<br>Maven Home directory：maven的安装目录<br>User Settings File：就是maven安装目录conf&#x2F;setting.xml配置文件<br>Local Repository：本机仓库的目录位置</p>
<p>–Build Tools–Maven–Runner<br>VM Options : -DarchetypeCatalog&#x3D;internal<br>JRE: 你项目的jdk</p>
<p>-DarchetypeCatalog&#x3D;internal , maven项目创建时，会联网下载模版文件，<br>比较大， 使用-DarchetypeCatalog&#x3D;internal，不用下载， 创建maven项目速度快。<br>②：配置以后新建工程的设置， file–other settings–Settings for New Project</p>
<h1 id="二、使用模版创建项目"><a href="#二、使用模版创建项目" class="headerlink" title="二、使用模版创建项目"></a>二、使用模版创建项目</h1><p>1）maven-archetype-quickstart : 普通的java项目<br>2）maven-archetype-webapp : web工程</p>
<h1 id="第四部分："><a href="#第四部分：" class="headerlink" title="第四部分："></a>第四部分：</h1><h1 id="一、依赖范围，使用scope表示的。"><a href="#一、依赖范围，使用scope表示的。" class="headerlink" title="一、依赖范围，使用scope表示的。"></a>一、依赖范围，使用scope表示的。</h1><p>scope的值有compile，test，provided，默认是compile<br>scope：表示依赖使用的范围，也就是在maven构建项目的那些阶段中起作用。<br>maven构建项目：编译、测试、打包、安装、部署 过程（阶段）</p>
<p>junit的依赖范围是 test<br>&lt;dependency&gt;<br>&lt;groupId&gt;junit&lt;&#x2F;groupId&gt;<br>&lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;<br>&lt;version&gt;4.11&lt;&#x2F;version&gt;<br>&lt;scope&gt;test&lt;&#x2F;scope&gt;（测试的时候才有效）<br>&lt;&#x2F;dependency&gt;</p>
<p>&lt;dependency&gt;<br>&lt;groupId&gt;a&lt;&#x2F;groupId&gt;<br>&lt;artifactId&gt;b&lt;&#x2F;artifactId&gt;   b.jar<br>&lt;version&gt;4.11&lt;&#x2F;version&gt;<br>不写但也是全局使用，compile在每个阶段<br>&lt;&#x2F;dependency&gt;</p>
<p>&lt;dependency&gt;<br>&lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;<br>&lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;<br>&lt;version&gt;3.1.0&lt;&#x2F;version&gt;servlet.jar<br>&lt;scope&gt;provided&lt;&#x2F;scope&gt; 提供者<br>&lt;&#x2F;dependency&gt;</p>
<p>你在写项目的中的用到的所有依赖（jar），必须在本地仓库中有。<br>没有必须通过maven下载， 包括provided的都必须下载。</p>
<p>你在servlet需要继承HttpServlet( provided) , 你使用的HttpServlet是maven仓库中的。</p>
<p>当你的写好的程序， 放到 tomat服务器中运行时， 此时你的程序中不包含servlet的jar<br>因为tomcat提供了 servlet的.jar</p>
<h1 id="第五部分："><a href="#第五部分：" class="headerlink" title="第五部分："></a>第五部分：</h1><p>maven常用操作</p>
<h1 id="一、maven的属性设置"><a href="#一、maven的属性设置" class="headerlink" title="一、maven的属性设置"></a>一、maven的属性设置</h1><p>&lt;properties&gt; 设置maven的常用属性</p>
<h1 id="二、maven的全局变量"><a href="#二、maven的全局变量" class="headerlink" title="二、maven的全局变量"></a>二、maven的全局变量</h1><p>自定义的属性，<br>1、在&lt;properties&gt; 通过自定义标签声明变量（标签名就是变量名）<br>2、在pom.xml文件中的其它位置，使用${标签名} 使用变量的值</p>
<p>自定义全局变量一般是定义依赖的版本号，当你的项目中要使用多个相同的版本号，<br>先使用全局变量定义，在使用${变量名}</p>
<h1 id="三、资源插件"><a href="#三、资源插件" class="headerlink" title="三、资源插件"></a>三、资源插件</h1><p>&lt;build&gt;<br>&lt;resources&gt;<br>&lt;resource&gt;<br>&lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;&lt;!–所在的目录–&gt;<br>&lt;includes&gt;&lt;!–包括目录下的.properties,.xml 文件都会扫描到–&gt;<br>&lt;include&gt;<strong>&#x2F;*.properties&lt;&#x2F;include&gt;<br>&lt;include&gt;</strong>&#x2F;*.xml&lt;&#x2F;include&gt;<br>&lt;&#x2F;includes&gt;<br>&lt;!—filtering 选项 false 不启用过滤器， *.property 已经起到过滤的作用了 –&gt;<br>&lt;filtering&gt;false&lt;&#x2F;filtering&gt;<br>&lt;&#x2F;resource&gt;<br>&lt;&#x2F;resources&gt;<br>&lt;&#x2F;build&gt;<br>作用： mybatis课程中会用到这个作用</p>
<p>1、默认没有使用resources的时候， maven执行编译代码时， 会把src&#x2F;main&#x2F;resource<br>目录中的文件拷贝到target&#x2F;classes目录中。<br>对于src&#x2F;main&#x2F;java目录下的非java文件不处理，不拷贝到target&#x2F;classes目录中<br>2、我们的程序有需要把一些文件放在src&#x2F;main&#x2F;java目录中，当我在执行 java程序时，<br>需要用到src&#x2F;main&#x2F;java目录中的文件，需要告诉maven在mvn compile<br>src&#x2F;main&#x2F;java 目录下的程序时，需要把文件一同拷贝到target&#x2F;classes目录中。<br>此时就需要在，&lt;build&gt;中加入，&lt;resources&gt;。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Maven/" rel="tag">Maven</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2022/02/18/Maven%E4%BB%8B%E7%BB%8D/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="Maven介绍">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-JDK动态代理AOP" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/02/18/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86AOP/" class="article-date">
  	<time datetime="2022-02-18T00:38:06.000Z" itemprop="datePublished">2022-02-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/18/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86AOP/">
        JDK动态代理AOP
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#（重点）动态代理（理解）： 基于反射机制。</p>
<h1 id="掌握的程度"><a href="#掌握的程度" class="headerlink" title="掌握的程度"></a>掌握的程度</h1><h2 id="1、什么是动态代理-？"><a href="#1、什么是动态代理-？" class="headerlink" title="1、什么是动态代理 ？"></a>1、什么是动态代理 ？</h2><p>使用jdk的反射机制，创建对象的能力， 创建的是代理类的对象。 而不用你创建类文件。不用写java文件。<br>动态：在程序执行时，调用jdk提供的方法才能创建代理类的对象。<br>jdk动态代理，必须有接口，目标类必须实现接口， 没有接口时，需要使用cglib动态代理</p>
<h2 id="2、知道动态代理能做什么-？"><a href="#2、知道动态代理能做什么-？" class="headerlink" title="2、知道动态代理能做什么 ？"></a>2、知道动态代理能做什么 ？</h2><p>可以在不改变原来目标方法功能的前提下， 可以在代理中增强自己的功能代码。<br>程序开发中的意思。<br>比如：你所在的项目中，有一个功能是其他人（公司的其它部门，其它小组的人）写好的，你可以使用。<br>GoNong.class ,  GoNong gn &#x3D; new GoNong(), gn.print();</p>
<p>你发现这个功能，现在还缺一点， 不能完全满足我项目的需要。<br>我需要在gn.print()执行后，需要自己在增加代码。<br>用代理实现 gn.print（）调用时， 增加自己代码， 而不用去改原来的 GoNong文件。</p>
<p>后面会讲 mybatis ，spring </p>
<h1 id="1、代理"><a href="#1、代理" class="headerlink" title="1、代理"></a>1、代理</h1><p>代购， 中介，换ip，商家等等</p>
<p>比如有一家美国的大学， 可以对全世界招生。 留学中介（代理）</p>
<p>留学中介（代理）： 帮助这家美国的学校招生，  中介是学校的代理， 中介是代替学校完成招生功能。<br>代理特点：</p>
<ol>
<li>中介和代理他们要做的事情是一致的：  招生。 </li>
<li>中介是学校代理， 学校是目标。</li>
<li>家长—中介（学校介绍，办入学手续）—-美国学校。</li>
<li>中介是代理，不能白干活，需要收取费用。</li>
<li>代理不让你访问到目标。</li>
</ol>
<p>为什么要找中介 ？ </p>
<ol>
<li>中介是专业的，方便</li>
<li>家长现在不能自己去找学校。 家长没有能力访问学校。 或者美国学校不接收个人来访。<br>买东西都是商家卖， 商家是某个商品的代理， 你个人买东西， 肯定不会让你接触到厂家的。</li>
</ol>
<h1 id="2、在开发中的情况，你有a类，-本来是调用c类的方法，完成某个功能，但是c不让a调用。"><a href="#2、在开发中的情况，你有a类，-本来是调用c类的方法，完成某个功能，但是c不让a调用。" class="headerlink" title="2、在开发中的情况，你有a类， 本来是调用c类的方法，完成某个功能，但是c不让a调用。"></a>2、在开发中的情况，你有a类， 本来是调用c类的方法，完成某个功能，但是c不让a调用。</h1><p>a —–不能调用 c的方法。<br>在 a 和 c 之间创建一个 b 代理，c 让 b 访问。<br>a –&gt;访问b—&gt;访问c</p>
<p>实际的例子： 登录，注册有验证码， 验证码是手机短信。</p>
<p>中国移动， 联通能发短信。<br>中国移动， 联通能有子公司，或者关联公司，他们面向社会提供短信的发送功能</p>
<p>张三项目发送短信—-子公司，或者关联公司—–中国移动， 联通</p>
<h1 id="3、使用代理模式的作用"><a href="#3、使用代理模式的作用" class="headerlink" title="3、使用代理模式的作用"></a>3、使用代理模式的作用</h1><p>1、功能增强： 在你原有的功能上，增加了额外的功能。 新增加的功能，叫做功能增强。<br>2、控制访问： 代理类不让你访问目标，例如商家不让用户访问厂家。 </p>
<h1 id="4、实现代理的方式"><a href="#4、实现代理的方式" class="headerlink" title="4、实现代理的方式"></a>4、实现代理的方式</h1><h2 id="1、静态代理-："><a href="#1、静态代理-：" class="headerlink" title="1、静态代理 ："></a>1、静态代理 ：</h2><p>1）代理类是自己手工实现的，自己创建一个java类，表示代理类。<br>2）同时你所要代理的目标类是确定的。<br>特点：1）实现简单  2）容易理解。3）提前确定好了代理的关系，写死了的<br>缺点：当你的项目中，目标类和代理类很多时候，有以下的缺点：<br>1）当目标类增加了， 代理类可能也需要成倍的增加。 代理类数量过多。<br>2）当你的接口中功能增加了， 或者修改了，会影响众多的实现类，厂家类，代理都需要修改。影响比较多。<br>模拟一个用户购买u盘的行为。<br>用户是客户端类<br>商家：代理，代理某个品牌的u盘。<br>厂家：目标类。</p>
<p>三者的关系： 用户（客户端）—商家（代理）—厂家（目标）<br>商家和厂家都是卖u盘的，他们完成的功能是一致的，都是卖u盘。</p>
<p>实现步骤：</p>
<ol>
<li>创建一个接口，定义卖u盘的方法， 表示你的厂家和商家做的事情。</li>
<li>创建厂家类，实现1步骤的接口</li>
<li>创建商家，就是代理，也需要实现1步骤中的接口。</li>
<li>创建客户端类，调用商家的方法买一个u盘。</li>
</ol>
<p>代理类完成的功能： </p>
<ol>
<li>目标类中方法的调用</li>
<li>功能增强</li>
</ol>
<h2 id="2、动态代理"><a href="#2、动态代理" class="headerlink" title="2、动态代理"></a>2、动态代理</h2><p>在静态代理中目标类很多时候，可以使用动态代理，避免静态代理的缺点。<br>动态代理中目标类即使很多， 1）代理类数量可以很少， 2）当你修改了接口中的方法时，不会影响代理类。</p>
<p>动态代理： 在程序执行过程中，使用jdk的反射机制，创建代理类对象， 并动态的指定要代理目标类。<br>换句话说： 动态代理是一种创建java对象的能力，让你不用创建TaoBao类，就能创建代理类对象。</p>
<p>在java中，要想创建对象：<br>1、创建类文件， java文件编译为class<br>2、使用构造方法，创建类的对象。</p>
<h2 id="动态代理的实现（有两种）："><a href="#动态代理的实现（有两种）：" class="headerlink" title="动态代理的实现（有两种）："></a>动态代理的实现（有两种）：</h2><p>1、jdk动态代理（理解）： 使用java反射包中的类和接口实现动态代理的功能。<br>反射包 java.lang.reflect , 里面有三个类：InvocationHandler , Method, Proxy。</p>
<ol start="2">
<li>cglib动态代理（了解）: cglib是第三方的工具库， 创建代理对象。<br>cglib的原理是继承， cglib通过继承目标类，创建它的子类，在子类中重写父类中同名的方法， 实现功能的修改。</li>
</ol>
<p>因为cglib是继承，重写方法，所以要求目标类不能是final的， 方法也不能是final的。<br>cglib的要求目标类比较宽松， 只要能继承就可以了。<br>cglib在很多的框架中使用， 比如 mybatis ，spring框架中都有使用。</p>
<h1 id="5、jdk动态代理："><a href="#5、jdk动态代理：" class="headerlink" title="5、jdk动态代理："></a>5、jdk动态代理：</h1><p>1、反射， Method类，表示方法。类中的方法。 通过Method可以执行某个方法。</p>
<h2 id="2、jdk动态代理的实现"><a href="#2、jdk动态代理的实现" class="headerlink" title="2、jdk动态代理的实现"></a>2、jdk动态代理的实现</h2><p>反射包 java.lang.reflect , 里面有三个类 ： InvocationHandler , Method, Proxy.<br>1）InvocationHandler 接口（调用处理器）：就一个方法invoke（）<br>invoke()：表示代理对象要执行的功能代码。<br>你的代理类要完成的功能就写在invoke()方法中。</p>
<p>代理类完成的功能：<br>1、调用目标方法，执行目标方法的功能<br>2、功能增强，在目标方法调用时，增加功能。</p>
<p>InvocationHandler 接口方法原型：参数：<br>Object proxy：jdk创建的代理对象，无需赋值。<br>Method method：目标类中的方法，jdk提供method对象的<br>Object[] args：目标类中方法的参数， jdk提供的。</p>
<p>public Object invoke(Object proxy, Method method, Object[] args)<br>InvocationHandler 接口：表示你的代理要干什么。<br>怎么用：<br>1、创建类实现接口InvocationHandler<br>2、重写invoke()方法， 把原来静态代理中代理类要完成的功能，写在这。</p>
<p>2）Method类：表示方法的， 确切的说就是目标类中的方法。和InvocationHandler 接口不同。<br>作用：通过Method可以执行某个目标类的方法，Method.invoke()；<br>method.invoke(目标对象，方法的参数)<br>Object ret &#x3D; method.invoke(service2, “李四”);</p>
<p>说明： method.invoke（）就是用来执行目标方法的，等同于静态代理中的<br>&#x2F;&#x2F;向厂家发送订单，告诉厂家，我买了u盘，厂家发货<br>float price &#x3D; factory.sell(amount); &#x2F;&#x2F;厂家的价格。</p>
<p>3）Proxy类：核心的对象，创建代理对象。之前创建对象都是 new 类的构造方法()<br>现在我们是使用Proxy类的方法，代替new的使用。 </p>
<p>方法： 静态方法 newProxyInstance()<br>作用是： 创建代理对象， 等同于静态代理中的TaoBao taoBao &#x3D; new TaoBao();</p>
<p>public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</p>
<p>静态方法 newProxyInstance() 参数：<br>1、ClassLoader loader 类加载器，负责向内存中加载对象的。 使用反射获取对象的<br>ClassLoader类a , a.getCalss().getClassLoader(),  目标对象的类加载器<br>2、Class&lt;?&gt;[] interfaces： 接口，目标对象实现的接口，也是反射获取的。<br>3、InvocationHandler handle：我们自己写的，代理类要完成的功能。<br>返回值：就是代理对象</p>
<h2 id="3、实现动态代理的步骤："><a href="#3、实现动态代理的步骤：" class="headerlink" title="3、实现动态代理的步骤："></a>3、实现动态代理的步骤：</h2><p>1、创建接口，定义目标类要完成的功能<br>2、创建目标类实现接口<br>3、创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能<br>1）调用目标方法<br>2）增强功能</p>
<h2 id="4、使用Proxy类的静态方法，创建代理对象。-并把返回值转为接口类型。"><a href="#4、使用Proxy类的静态方法，创建代理对象。-并把返回值转为接口类型。" class="headerlink" title="4、使用Proxy类的静态方法，创建代理对象。 并把返回值转为接口类型。"></a>4、使用Proxy类的静态方法，创建代理对象。 并把返回值转为接口类型。</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JDK/" rel="tag">JDK</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2022/02/18/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86AOP/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="JDK动态代理AOP">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-jQuery介绍" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/02/18/jQuery%E4%BB%8B%E7%BB%8D/" class="article-date">
  	<time datetime="2022-02-18T00:33:34.000Z" itemprop="datePublished">2022-02-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/18/jQuery%E4%BB%8B%E7%BB%8D/">
        jQuery介绍
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1、jQuery是js库："><a href="#1、jQuery是js库：" class="headerlink" title="1、jQuery是js库："></a>1、jQuery是js库：</h1><p>库：相当于java的工具类，库是存放东西的， jQuery是存放js代码的地方， 放的用js代码写的function</p>
<h1 id="2、dom对象和jquery对象"><a href="#2、dom对象和jquery对象" class="headerlink" title="2、dom对象和jquery对象"></a>2、dom对象和jquery对象</h1><h2 id="dom对象："><a href="#dom对象：" class="headerlink" title="dom对象："></a>dom对象：</h2><p>使用javascript的语法创建的对象叫做dom对象， 也就是js对象；<br>var obj&#x3D;  document.getElementById(“txt1”)；obj是dom对象，也叫做js对象<br>obj.value；获取dom对象的属性，调用其方法。</p>
<h2 id="jquery对象："><a href="#jquery对象：" class="headerlink" title="jquery对象："></a>jquery对象：</h2><p>使用jquery语法表示对象叫做jquery对象， 注意：jquery表示的对象都是数组；<br>例如：var jobj &#x3D;  $(“#txt1”)，jobj就是使用jquery语法表示的对象，也就是jquery对象，<br>它是一个数组，现在数组中就一个值。</p>
<h2 id="dom对象可以和jquery对象相互的转换；"><a href="#dom对象可以和jquery对象相互的转换；" class="headerlink" title="dom对象可以和jquery对象相互的转换；"></a>dom对象可以和jquery对象相互的转换；</h2><p>dom对象可以转为jquery ， 语法：$(dom对象)<br>jquery对象也可以转为dom对象， 语法：从数组中获取第一个对象， 第一个对象就是dom对象，<br>使用[0]或者get{0)；</p>
<h2 id="为什么要进行dom和jquery的转换："><a href="#为什么要进行dom和jquery的转换：" class="headerlink" title="为什么要进行dom和jquery的转换："></a>为什么要进行dom和jquery的转换：</h2><p>目的是要使用对象的方法，或者方法。</p>
<p>当你是dom对象时，可以使用dom对象的属性或者方法， 如果你要想使用jquery提供的函数，必须是jquery对象才可以。 </p>
<h1 id="3、基本选择器："><a href="#3、基本选择器：" class="headerlink" title="3、基本选择器："></a>3、基本选择器：</h1><p>选择器就是一个字符串，用来定位dom对象的。定位了dom对象，就可以通过jquery的函数操作dom；</p>
<h2 id="常用的选择器："><a href="#常用的选择器：" class="headerlink" title="常用的选择器："></a>常用的选择器：</h2><p>1）id选择器；语法：$(“#dom对象的id值”)<br>通过dom对象的id定位dom对象的。 通过id找对象， id在当前页面中是唯一值。<br>2）class选择器；语法：$(“.class样式名)<br>class表示css中的样式， 使用样式的名称定位dom对象的。<br>3）标签选择器；语法： $(“标签名称”)<br>使用标签名称定位dom对象的<br>4）组合选择器；<br>5）所有选择器；</p>
<h1 id="4、表单选择器："><a href="#4、表单选择器：" class="headerlink" title="4、表单选择器："></a>4、表单选择器：</h1><p>使用<input>标签的type属性值，定位dom对象的方式。<br>语法： $(“:type属性值”)<br>例如：<br>$(“:text”) ,选择的是所有的单行文本框，<br>$(“:button”) ,选择的是所有的按钮。</p>
<h1 id="5、基本过滤器："><a href="#5、基本过滤器：" class="headerlink" title="5、基本过滤器："></a>5、基本过滤器：</h1><p>在定位了dom对象后，根据一些条件筛选dom对象。<br>过滤器有是一个字符串，用来筛选dom对象的。<br>过滤器不能单独使用， 必须和选择器一起使用。</p>
<p>1）$(“选择器:first”)：第一个dom对象<br>2）$(“选择器:last”)：数组中的最后一个dom对象<br>3）$(“选择器:eq(数组的下标)”)：获取指定下标的dom对象<br>4）$(“选择器:lt(下标)”)：获取小于下标的所有dom对象<br>5）$(“选择器:gt(下标)”)：获取大于下标的所有dom对象</p>
<h1 id="6、表单属性过滤器："><a href="#6、表单属性过滤器：" class="headerlink" title="6、表单属性过滤器："></a>6、表单属性过滤器：</h1><p>根据表单中dom对象的状态情况，定位dom对象的。<br>    启用状态， enabled ,<br>    不可用状态  disabled<br>    选择状态 ， checked ， 例如radio， checkbox </p>
<h1 id="7、each语法（val，append，each这三个函数是使用最高的！）"><a href="#7、each语法（val，append，each这三个函数是使用最高的！）" class="headerlink" title="7、each语法（val，append，each这三个函数是使用最高的！）"></a>7、each语法（val，append，each这三个函数是使用最高的！）</h1><h2 id="1）可以对-数组，-json-，dom数组循环处理。"><a href="#1）可以对-数组，-json-，dom数组循环处理。" class="headerlink" title="1）可以对 数组， json ，dom数组循环处理。"></a>1）可以对 数组， json ，dom数组循环处理。</h2><p>数组， json中的每个成员都会调用一次处理函数。<br>var arr &#x3D; { 1, 2, 3} &#x2F;&#x2F;数组；<br>var json &#x3D; {“name”:”lisi”,”age”:20 } ；<br>var obj &#x3D; $(“:text”)；</p>
<p>语法：<br>$.each( 循环的内容，处理函数 )：表示使用jquery的each，循环数组，每个数组成员，都会执行后面的“处理函数”一次。<br>$：相当于是java的一个类名<br>each：就是类中的静态方法。<br>静态方法调用，可以使用：类名.方法名称 </p>
<p>处理函数：function(index, element) :<br>index, element都是自定义的形参， 名称自定义。<br>index：循环的索引<br>element：数组中的成员</p>
<p>js循环数组：<br>for(var i&#x3D;0;i&lt;arr.length;i++){<br>var item &#x3D; arr[i]; &#x2F;&#x2F;数组成员<br>&#x2F;&#x2F;操作数组成员<br>shuchu( i , item);<br>}<br>function shuchu(index, element){<br>输出index ，element；<br>}</p>
<h2 id="2）循环jquery对象，-jquery对象就是dom数组"><a href="#2）循环jquery对象，-jquery对象就是dom数组" class="headerlink" title="2）循环jquery对象， jquery对象就是dom数组"></a>2）循环jquery对象， jquery对象就是dom数组</h2><p>语法：jquery对象.each( function(index,element) {} )</p>
<h1 id="8、jquery中给dom对象绑定事件"><a href="#8、jquery中给dom对象绑定事件" class="headerlink" title="8、jquery中给dom对象绑定事件"></a>8、jquery中给dom对象绑定事件</h1><h2 id="1）-选择器-事件名称-事件的处理函数"><a href="#1）-选择器-事件名称-事件的处理函数" class="headerlink" title="1）$(选择器).事件名称(事件的处理函数)"></a>1）$(选择器).事件名称(事件的处理函数)</h2><p>$(选择器)：定位dom对象， dom对象可以有多个， 这些dom对象都绑定事件了<br>事件名称：就是js中事件去掉on的部分， 例如 js中的单击事件 onclick(),jquery中的事件名称，就是click，都是小写的。<br>事件的处理函数：就是一个function ，当事件发生时，执行这个函数的内容。<br>例如给id是btn的按钮绑定单击事件；<br>$(“#btn”).click(funtion(){<br>alert(“btn按钮单击了”)；<br>})</p>
<h2 id="2）on-事件绑定"><a href="#2）on-事件绑定" class="headerlink" title="2）on 事件绑定"></a>2）on 事件绑定</h2><p>$(选择器).on( 事件名称 , 事件的处理函数)<br>事件名称：就是js事件中去掉on的部分，例如js中onclick ，这里就是click<br>事件的处理函数：function 定义。<br>例如， <input type="button" id="btn"><br>$(“#btn”).on(“click”, function() { 处理按钮单击 } )</p>
<h1 id="9、使用jquery的函数，实现ajax请求的处理。"><a href="#9、使用jquery的函数，实现ajax请求的处理。" class="headerlink" title="9、使用jquery的函数，实现ajax请求的处理。"></a>9、使用jquery的函数，实现ajax请求的处理。</h1><p>没有jquery之前，使用XMLHttpRequest做ajax ， 有4个步骤。  jquery简化了ajax请求的处理。<br>使用三个函数可以实现ajax请求的处理：<br>1） $.ajax() : jquery中实现ajax的核心函数。<br>2） $.post() : 使用post方式做ajax请求。<br>3） $.get() : 使用get方式发送ajax请求。<br>$.post()和$.get() 他们在内部都是调用的 $.ajax()<br>介绍 $.ajax函数的使用， 函数的参数表示请求的url， 请求的方式，参数值等信息。<br>$.ajax()参数是一个json的结构。<br>例如： $.ajax(  {名称:值， 名称1:值1….. } )<br>例如：<br>$.ajax(  {  async:true ,<br>contentType:”application&#x2F;json” ,<br>data: {name:”lisi”,age:20 },<br>dataType:”json”,<br>error:function(){请求出现错误时，执行的函数},<br>success:function( data ) {&#x2F;&#x2F; data 就是responseText, 是jquery处理后的数据。},<br>url:”bmiAjax”,<br>type:”get”<br>})</p>
<h1 id="10、json结构的参数说明："><a href="#10、json结构的参数说明：" class="headerlink" title="10、json结构的参数说明："></a>10、json结构的参数说明：</h1><p>1）async：是一个boolean类型的值， 默认是true ，表示异步请求的。<br>可以不写async这个配置项，xmlHttp.open(get,url,true)，第三个参数一样的意思。<br>2）contentType: 一个字符串，表示从浏览器发送服务器的参数的类型。 可以不写。<br>例如你想表示请求的参数是json格式的， 可以写application&#x2F;json<br>3）data：可以是字符串，数组，json，表示请求的参数和参数值。 常用的是json格式的数据<br>4）dataType：表示期望从服务器端返回的数据格式，可选的有： xml ， html ，text ，json<br>当我们使用$.ajax()发送请求时， 会把dataType的值发送给服务器， 那我们的servlet能够<br>读取到dataType的值，就知道你的浏览器需要的是 json或者xml的数据，那么服务器就可以返回你需要的数据格式。<br>5）error：一个function ，表示当请求发生错误时，执行的函数。<br>error:function() {   发生错误时执行  }<br>6）success：一个function , 请求成功了，从服务器端返回了数据，会执行success指定函数<br>之前使用XMLHttpRequest对象， 当readyState&#x3D;&#x3D;4 &amp;&amp; status&#x3D;&#x3D;200的时候。<br>7）url：请求的地址<br>8）type：请求方式，get或者post， 不用区分大小写。 默认是get方式。<br>主要使用的是 url , data，dataType，success ；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jQuery/" rel="tag">jQuery</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2022/02/18/jQuery%E4%BB%8B%E7%BB%8D/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="jQuery介绍">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Ajax介绍" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/02/18/Ajax%E4%BB%8B%E7%BB%8D/" class="article-date">
  	<time datetime="2022-02-18T00:13:23.000Z" itemprop="datePublished">2022-02-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/18/Ajax%E4%BB%8B%E7%BB%8D/">
        Ajax介绍
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1、全局刷新和局部刷新"><a href="#1、全局刷新和局部刷新" class="headerlink" title="1、全局刷新和局部刷新"></a>1、全局刷新和局部刷新</h1><h2 id="全局刷新："><a href="#全局刷新：" class="headerlink" title="全局刷新："></a>全局刷新：</h2><p>整个浏览器被新的数据覆盖。 在网络中传输大量的数据，浏览器需要加载，渲染页面；</p>
<h2 id="局部刷新："><a href="#局部刷新：" class="headerlink" title="局部刷新："></a>局部刷新：</h2><p>在浏览器器的内部，发起请求，获取数据，改变页面中的部分内容，其余的页面无需加载和渲染。网络中数据传输量少， 给用户的感受好；<br>ajax是用来做局部刷新的：局部刷新使用的核心对象：异步对象（XMLHttpRequest）<br>这个异步对象是存在浏览器内存中的 ，使用JavaScript语法创建和使用XMLHttpRequest对象；</p>
<h2 id="2、ajax：Asynchronous–JavaScript–and–XML（异步的JavaScript和XML）"><a href="#2、ajax：Asynchronous–JavaScript–and–XML（异步的JavaScript和XML）" class="headerlink" title="2、ajax：Asynchronous–JavaScript–and–XML（异步的JavaScript和XML）"></a>2、ajax：Asynchronous–JavaScript–and–XML（异步的JavaScript和XML）</h2><p>Asynchronous：异步的意思、JavaScript：javascript脚本，在浏览器中执行<br>and：和、<br>XML：是一种数据格式<br>ajax是一种做局部刷新的新方法(2003)，不是一种语言；<br>ajax包含的技术主要有：JavaScript、dom、css、xml等；核心是：JavaScript 和 xml【被json代替】<br>JavaScript：负责创建异步对象， 发送请求， 更新页面的dom对象；<br>ajax请求需要服务器端的数据；<br>xml：网络中的传输的数据格式，使用json替换了xml ；<br>&lt;数据&gt;<br>&lt;数据1&gt;宝马1&lt;&#x2F;数据1&gt;<br>&lt;数据2&gt;宝马2&lt;&#x2F;数据2&gt;<br>&lt;数据3&gt;宝马3&lt;&#x2F;数据3&gt;<br>&lt;数据4&gt;宝马4&lt;&#x2F;数据4&gt;<br>&lt;&#x2F;数据&gt;</p>
<h1 id="3、ajax中使用XMLHttpRequest对象（Ajax核心步骤）"><a href="#3、ajax中使用XMLHttpRequest对象（Ajax核心步骤）" class="headerlink" title="3、ajax中使用XMLHttpRequest对象（Ajax核心步骤）"></a>3、ajax中使用XMLHttpRequest对象（Ajax核心步骤）</h1><h2 id="1）创建异步对象："><a href="#1）创建异步对象：" class="headerlink" title="1）创建异步对象："></a>1）创建异步对象：</h2><p>var xmlHttp &#x3D; new XMLHttpRequest()；</p>
<h2 id="2）给异步对象绑定事件："><a href="#2）给异步对象绑定事件：" class="headerlink" title="2）给异步对象绑定事件："></a>2）给异步对象绑定事件：</h2><p>onreadystatechange：当异步对象发起请求，获取了数据都会触发这个事件。<br>这个事件需要指定一个函数， 在函数中处理状态的变化。<br>btn.onclick &#x3D; fun1()<br>function fun1(){<br>alert(“按钮单击”)；<br>}<br>例如：<br>xmlHttp.onreadystatechange&#x3D; function(){<br>处理请求的状态变化。<br>if(xmlHttp.readyState &#x3D;&#x3D; 4 &amp;&amp; xmlHttp.status&#x3D;&#x3D; 200 ){<br>&#x2F;&#x2F;可以处理服务器端的数据，更新当前页面<br>var data &#x3D; xmlHttp.responseText;<br>document.getElementById(“name”).value&#x3D; data;<br>}}</p>
<h3 id="异步对象的属性-readyState-表示异步对象请求的状态变化："><a href="#异步对象的属性-readyState-表示异步对象请求的状态变化：" class="headerlink" title="异步对象的属性 readyState 表示异步对象请求的状态变化："></a>异步对象的属性 readyState 表示异步对象请求的状态变化：</h3><p>0：创建异步对象时， new XMLHttpRequest();<br>1：初始异步请求对象， xmlHttp.open(请求方式，请求地址，true)<br>2：发送请求， xmlHttp.send()<br>3：从服务器端获取了数据，此时3是异步对象内部使用， 获取了原始的数据。<br>4：异步对象把接收的数据处理完成后。 此时开发人员在4的时候处理数据。<br>在4的时候，开发人员做什么 ？更新当前页面；<br>异步对象的status属性：表示网络请求的状况的：200，404，500，需要是当status&#x3D;&#x3D;200时，表示网络请求是成功的；</p>
<h2 id="3）初始异步请求对象"><a href="#3）初始异步请求对象" class="headerlink" title="3）初始异步请求对象"></a>3）初始异步请求对象</h2><p>异步的方法open()；<br>xmlHttp.open(请求方式get|post, “服务器端的访问地址”, 同步|异步请求(默认是true，异步请求)）<br>例如：<br>xmlHttp.open(“get”, “loginServlet?name&#x3D;zs&amp;pwd&#x3D;123”,true)；</p>
<h2 id="4）使用异步对象发送请求"><a href="#4）使用异步对象发送请求" class="headerlink" title="4）使用异步对象发送请求"></a>4）使用异步对象发送请求</h2><p>xmlHttp.send()；<br>获取服务器端返回的数据，使用异步对象的属性 responseText；<br>使用例子：xmlHttp.responseText<br>回调：当请求的状态变化时，异步对象会自动调用onreadystatechange事件对应的函数；<br>访问地址： 使用get方式传递参数；<br><a target="_blank" rel="noopener" href="http://localhost:8080/course_myajax/bmiPrint?name=%E6%9D%8E%E5%9B%9B&amp;w=82&amp;h=1.8">http://localhost:8080/course_myajax/bmiPrint?name=李四&amp;w=82&amp;h=1.8</a></p>
<h1 id="4、json使用"><a href="#4、json使用" class="headerlink" title="4、json使用"></a>4、json使用</h1><h2 id="1、ajax发起请求——-servlet"><a href="#1、ajax发起请求——-servlet" class="headerlink" title="1、ajax发起请求——-servlet"></a>1、ajax发起请求——-servlet</h2><p>（返回的一个json格式的字符串 { name:”河北”, jiancheng:”冀”,”shenghui”:”石家庄”}）；</p>
<h2 id="2、json分类："><a href="#2、json分类：" class="headerlink" title="2、json分类："></a>2、json分类：</h2><p>1、json对象格式：JSONObject，这种对象的格式   名称:值， 也可以看做是 key:value 格式。<br>2、json数组格式：JSONArray，<br>基本格式：<br>[{ name:”河北”, jiancheng:”冀”,”shenghui”:”石家庄”} ,<br> { name:”山西”, jiancheng:”晋”,”shenghui”:”太原”} ]；</p>
<h1 id="5、为什么要使用json：jsonde-优点"><a href="#5、为什么要使用json：jsonde-优点" class="headerlink" title="5、为什么要使用json：jsonde 优点"></a>5、为什么要使用json：jsonde 优点</h1><p>1、json格式好理解<br>2、json格式数据在多种语言中，比较容易处理。 使用java， javascript读写json格式的数据比较容易。<br>3、json格式数据他占用的空间下，在网络中传输快， 用户的体验好。<br>处理json的工具库：Gson（google）；Fastjson（阿里），jackson， json-lib<br>在js中的，可以把json格式的字符串，转为json对象， json中的key，就是json对象的属性名；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ajax/" rel="tag">Ajax</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2022/02/18/Ajax%E4%BB%8B%E7%BB%8D/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="Ajax介绍">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-MVC开发规则" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/02/18/MVC%E5%BC%80%E5%8F%91%E8%A7%84%E5%88%99/" class="article-date">
  	<time datetime="2022-02-18T00:06:18.000Z" itemprop="datePublished">2022-02-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/18/MVC%E5%BC%80%E5%8F%91%E8%A7%84%E5%88%99/">
        MVC开发规则
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、介绍："><a href="#一、介绍：" class="headerlink" title="一、介绍："></a>一、介绍：</h1><p>1、MVC开发规则制定了互联网通信开发过程中必须出现角色有哪些<br>2、MVc开发规则制定了互联网通信开发过程中必须出现角色担负职责<br>3、MVC开发规则制定了互联网通信开发过程中必须出现角色的出场顺序</p>
<h1 id="二、角色："><a href="#二、角色：" class="headerlink" title="二、角色："></a>二、角色：</h1><p>DAO对象：DAO对象提供某张表文件的操作细节，降低对表文件操作难度。避免反复开发表文件操作的代码提高代码复用性<br>Service对象：服务对象，提供【业务】的具体解决方案。<br>Service对象一个方法指定一个业务的解决方案。避免业务开发重复性开发行为，提供复用性，网站每一个业务都有一个独立标准解决方案。</p>
<h1 id="三、业务："><a href="#三、业务：" class="headerlink" title="三、业务："></a>三、业务：</h1><p>浏览器向Http服务器发送请求；<br>用户向网站发送请求；<br>举个栗子：张三用户发送请求：要求在服务端实现将张三账户3000元钱转给李四账户<br>业务处理方案:<br>1、判断”张三”是否是当前系统中用户<br>2、判断”李四”是否是当前系统中用户<br>3、读取”张三账户余额”，判断余额是否充足<br>4、读取”李四账户余额”，背账<br>5、更新”张三账户余额 - 3000”<br>6、更新”李四账户余额 + 3000”</p>
<h1 id="四、业务特征："><a href="#四、业务特征：" class="headerlink" title="四、业务特征："></a>四、业务特征：</h1><p>1、真实业务场景中，一个业务往往包含多个分支任务。因此解决业务开发工作量往往比较巨大。<br>2、真实业务场景中，只有所有分支任务都能顺利成功解决，才可以认为当前业务处理成功。</p>
<h1 id="五、解决业务开发困扰："><a href="#五、解决业务开发困扰：" class="headerlink" title="五、解决业务开发困扰："></a>五、解决业务开发困扰：</h1><p>1、一个业务可能在网站的多个地方重复出现，如果不做【封装】，增加开发难度，进行业务解决代码重复性开发。<br>2、【百人有百味】：不同程序员面对同一个业务时，给出解决方案往往有偏差，导致最终解决数据会有偏差。</p>
<h1 id="六、MVC开发规则——互联网通信开发过程中必须出现角色有哪些"><a href="#六、MVC开发规则——互联网通信开发过程中必须出现角色有哪些" class="headerlink" title="六、MVC开发规则——互联网通信开发过程中必须出现角色有哪些"></a>六、MVC开发规则——互联网通信开发过程中必须出现角色有哪些</h1><p>一次互联网开发过程，必须出现角色有三个：</p>
<table>
<thead>
<tr>
<th align="center">目录</th>
<th align="center">目录</th>
<th align="center">目录</th>
<th align="center">目录</th>
<th align="center">目录</th>
</tr>
</thead>
<tbody><tr>
<td align="center">C</td>
<td align="center">controller</td>
<td align="center">object</td>
<td align="center">控制层对象</td>
<td align="center">(Servlet   对象)</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">model</td>
<td align="center">object</td>
<td align="center">业务模型对象</td>
<td align="center">(Service   对象)</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">view</td>
<td align="center">object</td>
<td align="center">视图层对象</td>
<td align="center">(jsp&#x2F;HttpServletResponse)</td>
</tr>
</tbody></table>
<h1 id="七、MVC开发规则——互联网通信开发过程中必须出现角色担负职责"><a href="#七、MVC开发规则——互联网通信开发过程中必须出现角色担负职责" class="headerlink" title="七、MVC开发规则——互联网通信开发过程中必须出现角色担负职责"></a>七、MVC开发规则——互联网通信开发过程中必须出现角色担负职责</h1><h2 id="C-Servlet对象-："><a href="#C-Servlet对象-：" class="headerlink" title="C (Servlet对象)："></a>C (Servlet对象)：</h2><p>1）【可以】调用【请求对象】读取【请求包】参数信息<br>2）【必须】调用【Service对象】处理业务<br>3）【必须】调用【视图层对象】将结果写入到响应体</p>
<h2 id="M-Service对象-："><a href="#M-Service对象-：" class="headerlink" title="M (Service对象)："></a>M (Service对象)：</h2><p>1）处理业务中所有分支任务<br>2）根据分支任务执行情况判断业务是否处理成功<br>3）必须通过return将处理结果返回给【控制层对象】</p>
<h2 id="V-jsp-x2F-HttpServletResponse"><a href="#V-jsp-x2F-HttpServletResponse" class="headerlink" title="V (jsp&#x2F;HttpServletResponse)"></a>V (jsp&#x2F;HttpServletResponse)</h2><p>1）禁止参与业务处理<br>2）唯一任务将处理结果写入到响应体</p>
<h1 id="八、互联网通信开发过程中必须出现角色的出场顺序"><a href="#八、互联网通信开发过程中必须出现角色的出场顺序" class="headerlink" title="八、互联网通信开发过程中必须出现角色的出场顺序"></a>八、互联网通信开发过程中必须出现角色的出场顺序</h1><p>请求调用顺序：浏览器发送请求—-&gt;Servlet—-&gt;Service—-&gt;DeptDao&#x2F;EmpDao                                                  </p>
<p>响应顺序：EmpDao&#x2F;DeptDao分支任务结果—-&gt;Service—-&gt;Servlet—-&gt;View—-&gt;响应体—-&gt;tomcat—-&gt;浏览器</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MVC/" rel="tag">MVC</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2022/02/18/MVC%E5%BC%80%E5%8F%91%E8%A7%84%E5%88%99/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="MVC开发规则">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-JavaScript高级应用篇" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/02/18/JavaScript%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E7%AF%87/" class="article-date">
  	<time datetime="2022-02-18T00:03:31.000Z" itemprop="datePublished">2022-02-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/18/JavaScript%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E7%AF%87/">
        JavaScript高级应用篇
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、-arguments：参数"><a href="#一、-arguments：参数" class="headerlink" title="一、 arguments：参数"></a>一、 arguments：参数</h1><p>1、JavaScript中，每一函数都包含一个arguments属性；<br>2、arguments属性是一个数组；<br>3、在函数调用时，将实参输入到函数的arguments中，再由arguments将数据传递给形参<br>4、arguments属性存在，可以将JavaScript中函数在调用时传递实参与形参进行格式，增加函数调用灵活性；<br>5、arguments属性只能在函数体内使用，不能在函数体外使用；</p>
<h1 id="二、function属性："><a href="#二、function属性：" class="headerlink" title="二、function属性："></a>二、function属性：</h1><p>1、介绍：<br>1）function是JavaScript中一种高级数据类型<br>2）一个function类型对象用于管理一个具体函数<br>3）Javascript中function类型相当于Java中Method类型<br>2、function类型对象声明方式：<br>1）标准声明方式<br>2）匿名声明方式<br>3、function类型对象声明方式—-标准声明方式<br>function函数对象名(参数1，参数2){<br>命令;<br>}<br>4、function类型对象声明方式—-匿名声明方式<br>var 函数对象名 &#x3D; function(参数1，参数2)(命令1，命令2.。。。)；<br>5、function类型对象的创建时机<br>浏览器在加载<script>时，共加载两次；<br>第一次加载，将<script>标签所有以标准形式声明函数对象进行创建<br>第二次加载，将<script>标签所有命令行按照自上而下顺序来执行</p>
<h1 id="三、局部变量与全局变量"><a href="#三、局部变量与全局变量" class="headerlink" title="三、局部变量与全局变量"></a>三、局部变量与全局变量</h1><p>1、局部变量：<br>1）定义：在函数执行体内，通过var修饰符声明的变量<br>function fun1 () {<br>var name ="mike"； // 局部变量<br>}<br>2）特征：局部变量只能在当前函数执行体使用，不能在函数执行体外使用<br>2、全局变量：<br>定义：<br>1、全局变量可以在当前HTML文件中所有的函数中使用<br>2、全局变量被声明时，自动分配给window对象作为其属性<br>声明全局变量：<br>第一种方式：直接在script标签下，通过var声明的变量，就是全局变量；<br>第二种方式：在函数执行体内，没有通过var修饰符修饰的变量也是全局变量；</p>
<h1 id="四、object类型对象特征"><a href="#四、object类型对象特征" class="headerlink" title="四、object类型对象特征:"></a>四、object类型对象特征:</h1><p>1、【定义】：在Javascript认为所有通过【构造函数】生成对象其数据类型都是object类型<br>2、【特征】：object类型对象在创建完毕后，可以根据实际情况，任意添加属性和方法，也可以移除属性和方法。<br>3、【属性维护】：<br>第一种维护方案：<br>添加属性：<br>object对象.新属性名 = 值；<br>添加函数：<br>object对象.新函数对象名 = function () { } ；<br>第二种维护方案<br>添加属性：<br>object对象["新属性名"] = 值；<br>添加函数：<br>object对象["新函数对象名"] = function；<br>移除对象属性和方法<br>del object.属性名<br>del object.函数名</p>
<h1 id="五、自定义构造函数"><a href="#五、自定义构造函数" class="headerlink" title="五、自定义构造函数"></a>五、自定义构造函数</h1><p>1、【命令】：<br>function函数对象名(){<br>}<br>2、【调用】：<br>var object类型对象 = new函数对象名() ；<br>3、【普通函数与构造函数区分】：<br>1）函数没有调用之前，无法区分函数身份，只能根据函数调用形式区分<br>2）判断普通函数：<br>var num =函数对象名()；<br>3）判断构造函数：<br>var num = new的数对象名()；<br>4）返回值：<br>普通函数运行后需要通过将执行结果返回，构造函数运行后，直接返回一个object类型的对象，此时函数return相当于无效！</p>
<h1 id="六、JavaScript中this指向："><a href="#六、JavaScript中this指向：" class="headerlink" title="六、JavaScript中this指向："></a>六、JavaScript中this指向：</h1><p>1、JavaScrit中this指向与Java中this指向完全一致的。<br>1）在构造函数，this指向当前构造函数生成object类型对象<br>2）在普通函数，this指向调用当前函数的实例对象</p>
<h1 id="七、JSON："><a href="#七、JSON：" class="headerlink" title="七、JSON："></a>七、JSON：</h1><p>1、前提：JavaScript中得到object类型对象方式<br>方式1：由构造函数生成的对象都是object类型对象<br>方式2：由JSON数据描述格式生成对象都是object类型对象<br>2、JSON数据描述格式：<br>JavaScript中获得object类型对象简化版；<br>3、标准命令格式：<br>var obj={ "属性名1":值，"属性名2":值}；<br>开发人员习惯于将由JSON生成object类型对象称为【JSON对象】；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2022/02/18/JavaScript%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E7%AF%87/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="JavaScript高级应用篇">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-JavaScript基础应用篇" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/02/18/JavaScript%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8%E7%AF%87/" class="article-date">
  	<time datetime="2022-02-17T23:57:03.000Z" itemprop="datePublished">2022-02-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/18/JavaScript%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8%E7%AF%87/">
        JavaScript基础应用篇
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、JavaScript作用："><a href="#一、JavaScript作用：" class="headerlink" title="一、JavaScript作用："></a>一、JavaScript作用：</h1><p>帮助浏览器对用户提出请求进行处理；一个BOM有多个document，一个document有多个DOM；</p>
<h1 id="二、DOM对象："><a href="#二、DOM对象：" class="headerlink" title="二、DOM对象："></a>二、DOM对象：</h1><p>1、DOM &#x3D; Document Object Model，文档模型对象<br>2、JavaScript不能直接操作HTM标签，只能通过HTM标签，关联的DOM对象对HTM标签下达指令。</p>
<h1 id="三、DOM对象生命周期："><a href="#三、DOM对象生命周期：" class="headerlink" title="三、DOM对象生命周期："></a>三、DOM对象生命周期：</h1><p>1、浏览器在接收到HTML文件之后，将HTML文件标签加载到浏览器缓存中，每当加载一个HTML标签时候，自动为这个标签生成一个实例对象，这个实例对象就是DOM对象<br>2、在浏览器关闭之前或请求其他资源文件之前，本次生成的DOM对象一直存活在浏览器缓存中；<br>3、在浏览器关闭时候,浏览器缓存中dom对象将要被销毁<br>4、在浏览器请求到新资源文件后，浏览器缓存中原有的dom对象将会被覆盖</p>
<h1 id="四、document对象"><a href="#四、document对象" class="headerlink" title="四、document对象:"></a>四、document对象:</h1><p>1、document对象被称为【文档对象】<br>2、document对象用于在浏览器内存中根据定位条件定位DOM对象</p>
<h1 id="五、document对象生命周期"><a href="#五、document对象生命周期" class="headerlink" title="五、document对象生命周期:"></a>五、document对象生命周期:</h1><p>1、在浏览器将网页中所有标签加载完毕后，在内存中将使用【树形结构】存储这些DOM对象。<br>在树形结构生成完毕后由浏览器生成一个document对象管理这颗树(DOM树)；<br>即在浏览器将接收网页中标签加载完毕后，自动在浏览器内存生成一个document对象。<br>2、一个浏览器运行期间，只会生成一个document对象。<br>3、在浏览器关闭时，负责将document对象进行销毁。</p>
<p>注意：<br>1、一个浏览器窗口只会生成一个document对象；<br>考试管理系统界面由三个部分，叫做三个窗口，会有三个document进行管理；<br>2、一个HTML文件就会有一个document；<br>3、一个BOM有多个document，一个document有多个DOM；</p>
<h1 id="六、通过document对象定位DOM对象方式："><a href="#六、通过document对象定位DOM对象方式：" class="headerlink" title="六、通过document对象定位DOM对象方式："></a>六、通过document对象定位DOM对象方式：</h1><h2 id="1、根据HTML标签的ID属性值定位DOM对象"><a href="#1、根据HTML标签的ID属性值定位DOM对象" class="headerlink" title="1、根据HTML标签的ID属性值定位DOM对象"></a>1、根据HTML标签的ID属性值定位DOM对象</h2><p>命令格式：var domobj &#x3D; document.getElementById(“id属性值”)；<br>举个栗子：var domobj &#x3D; document.getElementById (“one”) ;<br>通知document对象定位id属性等于one的标签关联的DOM对象</p>
<h2 id="2、根据HTML标签的name属性值定位DOM对象"><a href="#2、根据HTML标签的name属性值定位DOM对象" class="headerlink" title="2、根据HTML标签的name属性值定位DOM对象"></a>2、根据HTML标签的name属性值定位DOM对象</h2><p>命令格式：var domArray &#x3D; document.getElementsByName (“name属性值”)；<br>举个栗子：&lt;input type&#x3D;”checkbox” name&#x3D;”deptNo” value&#x3D;”10”&gt;部门10<br>&lt;input type&#x3D;”checkbox” name&#x3D;”deptNo” value&#x3D;”20”&gt;部门20<br>&lt;input type&#x3D;”checkbox” name&#x3D;”deptNo” value&#x3D;”30”&gt;部门30<br>var domArray &#x3D;document.getElementsByName (“deptNo”)；<br>通知document对象将所有name属性等于deptNo的标签关联的DOM对象进行定位并<br>封装到一个数组进行返回。domArray就是一个数组存放本次返回的所有DOM对象。</p>
<h2 id="3、根据HTML标签类型定位DOM对象"><a href="#3、根据HTML标签类型定位DOM对象" class="headerlink" title="3、根据HTML标签类型定位DOM对象"></a>3、根据HTML标签类型定位DOM对象</h2><p>命令格式：var domarray &#x3D;document.getElementsByTagName(“标签类型名”);<br>举个栗子：vardomArray &#x3D; document.getElementsByTagName ( “p”);<br>&lt;p&gt;段落标签&lt;&#x2F;p&gt;<br>通知document对象将所有段落标签关联的dom对象进行定位并封装到一个数组返回；</p>
<h1 id="七、DOM对象对HTML标签属性操作"><a href="#七、DOM对象对HTML标签属性操作" class="headerlink" title="七、DOM对象对HTML标签属性操作"></a>七、DOM对象对HTML标签属性操作</h1><h2 id="1、DOM对象对标签value属性进行取值与赋值操作"><a href="#1、DOM对象对标签value属性进行取值与赋值操作" class="headerlink" title="1、DOM对象对标签value属性进行取值与赋值操作"></a>1、DOM对象对标签value属性进行取值与赋值操作</h2><p>取值操作：<br>var domObj&#x3D; document.getElementById(“one”)；<br>var num &#x3D; domobj.value；<br>赋值操作：<br>var domobj &#x3D; document.getElementById(“one”)：<br>domobj.value &#x3D; “abc”；</p>
<h2 id="2、DOM对象对标签中样式属性进行取值与赋值操作"><a href="#2、DOM对象对标签中样式属性进行取值与赋值操作" class="headerlink" title="2、DOM对象对标签中样式属性进行取值与赋值操作"></a>2、DOM对象对标签中样式属性进行取值与赋值操作</h2><p>取值操作：<br>var domobj &#x3D; document.getElementById(“one”)；&#x2F;&#x2F;读取当前标签【背景颜色属性】值<br>var color &#x3D; domobj.style.背景颜色属性；<br>赋值操作：<br>var domobj &#x3D; document.getElementById(“one”)；&#x2F;&#x2F;通过DOM对象对背景颜色属进行赋值<br>domobj.style.背景颜色属性&#x3D;值；</p>
<h2 id="3、DOM对象对标签中状态属性进行取值与赋值操作"><a href="#3、DOM对象对标签中状态属性进行取值与赋值操作" class="headerlink" title="3、DOM对象对标签中状态属性进行取值与赋值操作"></a>3、DOM对象对标签中状态属性进行取值与赋值操作</h2><p>状态属性：状态属性的值都是boolean类型；<br>disabled &#x3D; true；表示当前标签不可以使用<br>disabled &#x3D; false；表示当前标签可以使用<br>checked：只存在与radio标签与checkbox标签；<br>checked &#x3D; true ；表示当前标签被选中了。<br>checked &#x3D; false；表示当前标签未被选中。<br>取值操作：<br>var domobj &#x3D; document.getElementById(“one”) ；<br>var num &#x3D; domObj.checked；<br>赋值操作：<br>var domobj&#x3D; document.getElementById(“one”) ；<br>domobj.checked &#x3D; true；<br>4、DOM对象对标签中文字显示内容进行赋值与取值<br>文字显示内容：只存在于双目标签之间;&lt;tr&gt;100&lt;&#x2F;tr&gt;<br>取值操作：<br>var domObj &#x3D; document.getElementByid(“one”) ；<br>var num1 &#x3D; domobj.innerText；<br>赋值操作：<br>var domObj &#x3D; document.getElementByid(“one”)；<br>domObj.innerText &#x3D;值；</p>
<h2 id="innerText与innerHTM区别；"><a href="#innerText与innerHTM区别；" class="headerlink" title="innerText与innerHTM区别；"></a>innerText与innerHTM区别；</h2><p>innerText与innerHTML都可以对标签文字显示内容属性进行赋值与取值：<br>innerText只能接收字符串；<br>innerHTML既可以接收字符串又可以接收html标签；</p>
<h1 id="八、JavaScript监听事件"><a href="#八、JavaScript监听事件" class="headerlink" title="八、JavaScript监听事件"></a>八、JavaScript监听事件</h1><h2 id="1、监听事件："><a href="#1、监听事件：" class="headerlink" title="1、监听事件："></a>1、监听事件：</h2><p>监听用户在何时以何种方式对当前标签进行操作；<br>当监听到相关行为时，通知浏览器调用对应Javascript函数对当前用户请求进行处理；</p>
<h2 id="2、监听事件分类："><a href="#2、监听事件分类：" class="headerlink" title="2、监听事件分类："></a>2、监听事件分类：</h2><p>1）监听用户何时使用鼠标操作当前标签；<br>2）监听用户何时使用键盘操作当前标签；</p>
<h2 id="3、监听用户何时使用鼠标操作当前标签："><a href="#3、监听用户何时使用鼠标操作当前标签：" class="headerlink" title="3、监听用户何时使用鼠标操作当前标签："></a>3、监听用户何时使用鼠标操作当前标签：</h2><p>1）onclick：监听用户何时使用鼠标【单击】当前标签；<br>2）onblur：监听用户何时通过鼠标让当前标签丢失【光标】<br>3）onfocus：监听用户何时通过鼠标让当前标签获得【光标】<br>4）onmopseout：监听用户何时将鼠标从当前标签上方【移开】；<br>5）onmouseover：监听用户何时将鼠标【悬停】当前标签上方；</p>
<h2 id="4、监听用户何时使用键盘操作当前标签"><a href="#4、监听用户何时使用键盘操作当前标签" class="headerlink" title="4、监听用户何时使用键盘操作当前标签"></a>4、监听用户何时使用键盘操作当前标签</h2><p>1）onkeydown：监听用户何时在当前标签上【按下键盘】<br>2）onkeyup：监听用户何时在当前标签上【弹起键盘】</p>
<h1 id="九、onload监听事件："><a href="#九、onload监听事件：" class="headerlink" title="九、onload监听事件："></a>九、onload监听事件：</h1><p>1、作用：监听浏览器何时将网页中HTML标签加载完毕<br>2、意义：浏览器每加载一个HTML标签时，自动在内存生成一个dom对象。<br>在浏览器将网页所有标签加载完毕时，意味当前网页中所有标签都生成对应DOM对象<br>3、使用：<br>&lt;script type&#x3D;”text&#x2F;javascript”&gt;<br>function fun1() {<br>window. alert(“fun1 is run. . .”)；<br>}<br>&lt;&#x2F;script&gt;<br>&lt;body onload&#x3D;”fun1 () “&gt;<br>&lt;&#x2F;body&gt;</p>
<h1 id="十、基于DOM对象实现监听事件与HTML标签之间绑定"><a href="#十、基于DOM对象实现监听事件与HTML标签之间绑定" class="headerlink" title="十、基于DOM对象实现监听事件与HTML标签之间绑定"></a>十、基于DOM对象实现监听事件与HTML标签之间绑定</h1><p>1、前提：实际开发过程中，同一个监听事件往往与多个HTML标签进行绑定，这样增加开发强度，在未来维护过程中增加维护难度<br>2、命令形式：<br>domobj.监听事件名 &#x3D; 处理函数名；<br><em>此处处理函数名后面是不能出现()</em><br>3、举个栗子：<br>var domobj &#x3D; document.getElementById(“one” )；<br>domobj.onclick &#x3D; fun1；&#x2F;&#x2F; 注意函数名后面不能有()<br>相当于；<br>&lt;input type&#x3D;”button” id&#x3D;”one” onclick&#x3D;”fun1()”&gt;&#x2F;&#x2F;  此处函数名后面必须有()</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2022/02/18/JavaScript%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8%E7%AF%87/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="JavaScript基础应用篇">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-JavaScript语法介绍篇" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/02/18/JavaScript%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D%E7%AF%87/" class="article-date">
  	<time datetime="2022-02-17T23:46:22.000Z" itemprop="datePublished">2022-02-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/18/JavaScript%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D%E7%AF%87/">
        JavaScript语法介绍篇
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、介绍："><a href="#一、介绍：" class="headerlink" title="一、介绍："></a>一、介绍：</h1><p>1、Javascript是一种专门在浏览器编译并执行的编程语言<br>2、Javascript处理用户与浏览器之间请求问题<br>3、Javascript采用【弱类型编程语言风格】对【面向对象思想】来进行实现的编程语言</p>
<h1 id="二、弱类型编程语言风格-vs-强类型编程语言风格"><a href="#二、弱类型编程语言风格-vs-强类型编程语言风格" class="headerlink" title="二、弱类型编程语言风格 vs 强类型编程语言风格"></a>二、弱类型编程语言风格 vs 强类型编程语言风格</h1><h2 id="1、强类型编程语言风格："><a href="#1、强类型编程语言风格：" class="headerlink" title="1、强类型编程语言风格："></a>1、强类型编程语言风格：</h2><p>认为对象行为应该受到其修饰类型严格约束。<br>Java采用【强类型编程语言风格】对【面向对象思想】来进行实现的编程语言<br>class student{；<br>public string sname；<br>public void sayHello () {；<br>system.out.print ( “hello wor1d”)；<br>}；}；<br>studentstu &#x3D; new student()；<br>stu.sname&#x3D;”mike”；&#x2F;&#x2F; stu对象能够调用属性只有sname<br>stu.sayHello()；&#x2F;&#x2F; stu对象能够调用方法只有sayHello()<br>stu.sid &#x3D;10；&#x2F;&#x2F; 在Java认为是语法错误，修饰stu对象的student类型没有提供这个属性</p>
<h2 id="2、弱类型编程语言风格："><a href="#2、弱类型编程语言风格：" class="headerlink" title="2、弱类型编程语言风格："></a>2、弱类型编程语言风格：</h2><p>认为对象行为不应该受到其修饰类型约束。可以根据实际需要来决定对象可以调用属性和方法；<br>Javascript采用【弱类型编程语言风格】对【面向对象思想】来进行实现的编程语言<br>var stu &#x3D; new object()；&#x2F;&#x2F; stu对象相当于【阿Q】<br>stu.car &#x3D; “劳斯莱斯”；&#x2F;&#x2F; 合法<br>stu.play &#x3D; function () {return “天天打游戏”}<br>stu.play ()；</p>
<h1 id="三、Javascript中变量声明方式"><a href="#三、Javascript中变量声明方式" class="headerlink" title="三、Javascript中变量声明方式:"></a>三、Javascript中变量声明方式:</h1><p>1、命令格式：<br>var变量名；<br>var变量名&#x3D;值；<br>var变量名1,变量名2&#x3D;值；<br>2、注意：在JavaScript变量&#x2F;对象，在声明不允许指定【修饰类型】，只能通过var来进行修饰。</p>
<h1 id="四、JavaScript中标识符命名规则"><a href="#四、JavaScript中标识符命名规则" class="headerlink" title="四、JavaScript中标识符命名规则:"></a>四、JavaScript中标识符命名规则:</h1><p>1、标识符只能由四种符号组成英文字母，数字，下划线，美元符号($)；<br>2、标识符首字母不能以n数字”开头；<br>3、标识符不能采用JavaScript关键字比如var；</p>
<h1 id="五、-JavaScript数据类型"><a href="#五、-JavaScript数据类型" class="headerlink" title="五、 JavaScript数据类型:"></a>五、 JavaScript数据类型:</h1><p>1、分类：基本数据类型&amp;高级引用数据类型<br>2、基本数据类型：数字类型(number) ；字符串类型(string) ；布尔类型(boolean)；<br>3、数字类型(number)：JavaScript中将整数与小数合称为number类型<br>4、字符串类型(string)：JavaScript中字符与字符串合称为string类型Javascript字符或则字符串既可以使用’又可以使用” “<br>5、布尔类型(boolean)：Javascript中boolean类型的值只有true或则false<br>6、高级引用数据类型：object类型；function类型<br>7、object类型：JavaScript中所有通过【构造函数】生成的对象都是object类型<br>8、function类型：相当于Java中(java.lang.reflect.Method)JavaScript所有的函数都是function类型</p>
<h1 id="六、Javascript中特殊【值】"><a href="#六、Javascript中特殊【值】" class="headerlink" title="六、Javascript中特殊【值】"></a>六、Javascript中特殊【值】</h1><h2 id="1、undefined："><a href="#1、undefined：" class="headerlink" title="1、undefined："></a>1、undefined：</h2><p>Javascript中所有变量在没有赋值时，其默认值都是undefined<br>由于Javascript根据变量的赋值来判断变量类型，此时由于变量没有赋值<br>因此Javascript无法判断当前变量数据类型，此时返回也是undefiled，<br>因此初学者将undefined也理解为是一种数据类型，这种理解是错误</p>
<h2 id="2、null："><a href="#2、null：" class="headerlink" title="2、null："></a>2、null：</h2><p>Javascript中当一个对象赋值为null时，表示对象引用了一个【空内存】<br>这个空内存既不能存储数据也不能读取数据。<br>此时这个对象数据类型，在Javascript依然认为是object类型</p>
<h2 id="3、NaN："><a href="#3、NaN：" class="headerlink" title="3、NaN："></a>3、NaN：</h2><p>Javascript中当一个变量赋值为NaN，表示变量接收了一个【非法数字】<br>(123合法数字abc123非法数字)<br>此时这个变量数据类型，在Javascript依然认为number类型</p>
<h2 id="4、infinity："><a href="#4、infinity：" class="headerlink" title="4、infinity："></a>4、infinity：</h2><p>Javascript中当一个变量赋值为infinity，表示变量接收了一个【无穷大数字】<br>此时这个变量数据类型，在Javascript依然认为number类型</p>
<h1 id="七、Javascript中控制语句"><a href="#七、Javascript中控制语句" class="headerlink" title="七、Javascript中控制语句"></a>七、Javascript中控制语句</h1><p>Javascript中控制语句与Java中控制语句语法格式完全一致</p>
<h1 id="八、Javascript中函数声明方式"><a href="#八、Javascript中函数声明方式" class="headerlink" title="八、Javascript中函数声明方式"></a>八、Javascript中函数声明方式</h1><p>1、命令格式：<br>function  函数名（形参名1，形参名2){<br>Javascript命令行<br>Javascript命令行<br>return将函数运行结果进行返回<br>}<br>2、注意：<br>1）Javascript中，所有函数在声明时，都需要使用function进行修饰<br>2）Javascript中，所有函数在声明时，禁止指定函数返回数据类型<br>3）Javascript中，所有函数在声明时，形参既不能使用var来修饰也不能使用数据类型修饰<br>4）Javascript中，所有函数在声明时，如果有返回值，此时应该通过return进行返回</p>
<h1 id="九、JavaScript函数调用方式"><a href="#九、JavaScript函数调用方式" class="headerlink" title="九、JavaScript函数调用方式:"></a>九、JavaScript函数调用方式:</h1><p>1、浏览器并不会自动调用JavaScript函数<br>2、可以通过命令行方式来调用Java函数<br>3、通过绑定在HTML标签上监听事件通知浏览器调用指定函数进行处理</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2022/02/18/JavaScript%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D%E7%AF%87/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="JavaScript语法介绍篇">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-EL表达式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/02/18/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="article-date">
  	<time datetime="2022-02-17T23:36:41.000Z" itemprop="datePublished">2022-02-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/18/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/">
        EL表达式
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、EL表达式"><a href="#一、EL表达式" class="headerlink" title="一、EL表达式"></a>一、EL表达式</h1><p>1、命令格式：${作用域对象别名.共享数据}<br>2、命令作用：<br>1）EL表达式是式工具包提供一种特殊命令格式【表达式命令格式】<br>2）EL表达式在JSP文件上使用<br>3）负责在JSP文件上从作用域对象读取指定的共享数据并输出到响应体</p>
<h1 id="二、EL表达式—作用域对象别名"><a href="#二、EL表达式—作用域对象别名" class="headerlink" title="二、EL表达式—作用域对象别名"></a>二、EL表达式—作用域对象别名</h1><p>1、JSP文件可以使用的作用域对象<br>1）ServletContext—-application：全局作用域对象；<br>2）Httpsession—-session：会话作用域对象；<br>3）HttpServletRequest—-request：请求作用域对象；<br>4）PageContext—-pageContext：当前页作用域对象；<br>这是JSP文件独有作用域对象。servlet中不存在在当前页作用域对象存放的共享数据仅能在当前JSP文件中使用，不能共享给其他servlet或则其他JSP文件。<br>真实开发过程,主要用于5STL标签与JSP文件之间数据共享数据JSTL——&gt;pageContext—-&gt;JSP<br>2、EL表达式提供作用域对象别名</p>
<table>
<thead>
<tr>
<th align="center">目录</th>
<th align="center">目录</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JSP</td>
<td align="center">EL表达式</td>
</tr>
<tr>
<td align="center">application</td>
<td align="center">${applicationscope.共享数据名}</td>
</tr>
<tr>
<td align="center">session</td>
<td align="center">${sessionscope.共享数据名}</td>
</tr>
<tr>
<td align="center">request</td>
<td align="center">${requestscope.共享数据名}</td>
</tr>
<tr>
<td align="center">pageContext</td>
<td align="center">${pagescope.共享数据名}</td>
</tr>
</tbody></table>
<h1 id="三、EL表达式将引用对象属性写入到响应体"><a href="#三、EL表达式将引用对象属性写入到响应体" class="headerlink" title="三、EL表达式将引用对象属性写入到响应体"></a>三、EL表达式将引用对象属性写入到响应体</h1><p>1、命令格式：${作用域对象别名.共享数据名.属性名}<br>2、命令作用：从作用域对象读取指定共享数据关联的引用对象的属性值。并自动将属性的结果写入到响应体<br>3、属性名：一定要去引用类型属性名完全一致(大小写)<br>4、EL表达式没有提供遍历集合方法，因此无法从作用域对象读取集合内容输出</p>
<h1 id="四、EL表达式简化版"><a href="#四、EL表达式简化版" class="headerlink" title="四、EL表达式简化版"></a>四、EL表达式简化版</h1><p>1、命令格式：${共享数据名}<br>2、命令作用：EL表达式允许开发人员开发时省略作用域对象别名<br>3、工作原理：<br>EL表达式简化版由于没有指定作用域对象，所以在执行时采用【猜】算法<br>首先到【pageContext】定位共享数据，如果存在直接读取输出并结束执行<br>如果在【pageContext】没有定位成功，到【request】定位共享数据，如果存在直接读取输出并结束执行<br>如果在【request】没有定位成功，到【session】定位共享数据，如果存在直接读取输出并结束执行<br>如果在【session】没有定位成功，到【application】定位共享数据，如果存在直接读取输出并结束执行<br>如果在【application】没有定位成功,返回null，pageContext—&gt;request—&gt;session—&gt;applicationl<br>4、存在隐患：容易降低程序执行速度【南辕北辙】；容易导致数据定位错误；<br>5、应用场景：设计目的，就是简化从pageContext读取共享数据并输出难度；<br>6、EL表达式简化版尽管存在很多隐患，但是在实际开发过程中，开发人员为了节省时间，一般都使用简化版，拒绝使用标准版；</p>
<h1 id="五、EL表达式—–支持运算表达式"><a href="#五、EL表达式—–支持运算表达式" class="headerlink" title="五、EL表达式—–支持运算表达式"></a>五、EL表达式—–支持运算表达式</h1><p>1、前提：在JSP文件有时需要将读取共享数据进行一番运算之后，将运算结果写入到响应体；<br>2、运算表达式：<br>1）数学运算；<br>2）关系运算：&gt;、&gt;&#x3D;、&#x3D;&#x3D;、&lt;、&lt;&#x3D;、!&#x3D;<br>————–gt—-ge—-eq—lt—-le—-!&#x3D;<br>3）逻辑运算：&amp;&amp;、、ll、! </p>
<h1 id="六、EL表达式提供内置对象"><a href="#六、EL表达式提供内置对象" class="headerlink" title="六、EL表达式提供内置对象"></a>六、EL表达式提供内置对象</h1><h2 id="param"><a href="#param" class="headerlink" title="param"></a>param</h2><p>1、命令格式:${param.请求参数名}<br>2、命令作用:从通过请求对象读取当前请求包中请求参数内容并将请求参数内容写入到响应体<br>3、代替命令：index.jsp<br>发送请求：Http:&#x2F;&#x2F;localhost:8080&#x2F;myweb&#x2F;index.jsp?userName&#x3D;mike&amp;password&#x3D;123<br>&lt;%<br>string userName &#x3D; request.getParameter ( “userName” ) ；<br>string password &#x3D;request.getParameter ( “password”)；<br>%&gt;<br>&lt;%&#x3D;userName%&gt;<br>&lt;%&#x3D;password%&gt;</p>
<h2 id="paramvalue"><a href="#paramvalue" class="headerlink" title="paramvalue"></a>paramvalue</h2><p>1、命令格式：${paramvalue.请求参数名[下标]}<br>2、命令作用:如果浏览器发送的请求参数是[一个请求参数关联多个值J<br>此时可以通过paramvaues读取请求参数下指定位置的值并写入到响应体<br>3、代替命令: <a target="_blank" rel="noopener" href="http://localhost:8080/myweb/index2.jsp?pageNo=1&amp;pageNo=2&amp;pagNo=3">http://localhost:8080/myweb/index2.jsp?pageNo=1&amp;pageNo=2&amp;pagNo=3</a><br>此时pageNo请求参数在请求包以数组形式存在<br>pageNo: [1,2,3]<br>&lt;%<br>string  array[] &#x3D; request.getParametervalues ( “pageNo”)；<br>%&gt;<br>第一个值：&lt;%&#x3D;array [0]%&gt;<br>第二个值：&lt;%&#x3D;array [1]%&gt;</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/EL/" rel="tag">EL</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2022/02/18/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="EL表达式">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-JSP文件运行原理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/02/18/JSP%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/" class="article-date">
  	<time datetime="2022-02-17T23:34:09.000Z" itemprop="datePublished">2022-02-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/18/JSP%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/">
        JSP文件运行原理
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Http服务器调用JSP文件步骤-【2019年北京地区常考面试题】"><a href="#Http服务器调用JSP文件步骤-【2019年北京地区常考面试题】" class="headerlink" title="Http服务器调用JSP文件步骤:【2019年北京地区常考面试题】"></a>Http服务器调用JSP文件步骤:【2019年北京地区常考面试题】</h1><p>1、Htt如服务器将JSP文件内容【编辑】为一个servlet接口实现类(.java)<br>2、Http服务器将servlet接口实现类【编译】为class文件(.class)<br>3、Http服务器负责创建这个class的实例对象，这个实例对象就是servlet实例对象<br>4、Http服务器通过servlet实例对象调用_jspService方法，将jsp文件内容写入到响应体</p>
<h1 id="Http服务器【编辑】与【编译】JSP文件位置"><a href="#Http服务器【编辑】与【编译】JSP文件位置" class="headerlink" title="Http服务器【编辑】与【编译】JSP文件位置:"></a>Http服务器【编辑】与【编译】JSP文件位置:</h1><p>标准答案：我在【work】下看到这个证据；<br>C: Users[登录windows系统用户角色名1.Intelli3Tdea2018.3\system\tomcat[网站工作空间]；<br>work\catalina\localhost\myWeb\org\apache\jsp；<br>这个路径中含有编译时的java和class文件；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2022/02/18/JSP%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="JSP文件运行原理">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 John Doe
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>